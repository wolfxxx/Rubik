<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>3D Rubik's Cube Simulator</title>
  <style>
    :root {
      --bg-0: #0b1020;
      --bg-1: #131a2e;
      --panel: rgba(10, 12, 20, 0.7);
      --panel-border: rgba(255, 255, 255, 0.12);
      --text: #e7ecff;
      --muted: #a4b0d0;
      --accent: #55c2ff;
      --btn: #1d2947;
      --btn-hover: #27365f;
      --btn-active: #32457c;
    }

    * { box-sizing: border-box; }

    html, body {
      margin: 0;
      height: 100%;
      overflow: hidden;
      font-family: "Segoe UI", "Helvetica Neue", Arial, sans-serif;
      color: var(--text);
      background:
        radial-gradient(1200px 600px at 20% -10%, #20305d66, transparent 65%),
        radial-gradient(900px 500px at 90% 120%, #1e4d6a55, transparent 60%),
        linear-gradient(145deg, var(--bg-0), var(--bg-1));
    }

    #app {
      position: fixed;
      inset: 0;
    }

    canvas {
      display: block;
      width: 100%;
      height: 100%;
    }

    .hud {
      position: fixed;
      left: 16px;
      top: 16px;
      width: min(94vw, 380px);
      padding: 14px;
      border-radius: 12px;
      background: var(--panel);
      border: 1px solid var(--panel-border);
      backdrop-filter: blur(8px);
      box-shadow: 0 14px 35px rgba(0, 0, 0, 0.35);
      user-select: none;
      z-index: 20;
      transition: transform 180ms ease, opacity 180ms ease;
    }

    .hud-toggle {
      display: none;
      position: fixed;
      left: 12px;
      top: 12px;
      z-index: 30;
      width: auto;
      padding: 8px 12px;
      font-weight: 600;
      backdrop-filter: blur(8px);
      background: rgba(18, 26, 46, 0.82);
      border-color: var(--panel-border);
    }

    .title {
      font-size: 1.05rem;
      font-weight: 650;
      margin: 0 0 8px;
      letter-spacing: 0.2px;
    }

    .hint {
      margin: 0 0 12px;
      color: var(--muted);
      font-size: 0.86rem;
      line-height: 1.3;
    }

    .grid {
      display: grid;
      grid-template-columns: repeat(6, minmax(0, 1fr));
      gap: 6px;
      margin-bottom: 8px;
    }

    button {
      appearance: none;
      border: 1px solid #ffffff22;
      border-radius: 8px;
      background: var(--btn);
      color: var(--text);
      font-size: 0.86rem;
      padding: 8px 0;
      cursor: pointer;
      transition: background 120ms ease, transform 60ms ease;
    }

    button:hover { background: var(--btn-hover); }
    button:active {
      background: var(--btn-active);
      transform: translateY(1px);
    }

    .toolbar {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 6px;
      margin-top: 4px;
    }

    .footer {
      margin-top: 8px;
      color: var(--muted);
      font-size: 0.75rem;
    }

    .kbd {
      color: var(--accent);
      font-family: Consolas, "SFMono-Regular", Menlo, monospace;
    }

    @media (max-width: 768px) {
      .hud {
        width: min(92vw, 360px);
        max-height: calc(100dvh - 24px);
        overflow: auto;
      }

      .hud.mobile-collapsed {
        transform: translateY(calc(-100% - 20px));
        opacity: 0;
        pointer-events: none;
      }

      .hud-toggle {
        display: inline-block;
      }
    }
  </style>
</head>
<body>
  <div id="app"></div>

  <button id="hudToggle" class="hud-toggle" aria-expanded="false">Show Controls</button>

  <div class="hud" id="hudPanel">
    <h1 class="title">3D Rubik's Cube Simulator</h1>
    <p class="hint">
      Drag to orbit, wheel to zoom. Click a move or use keys:
      <span class="kbd">U D L R F B</span> (hold <span class="kbd">Shift</span> for inverse).
    </p>

    <div class="grid" id="moves"></div>

    <div class="toolbar">
      <button id="scramble">Scramble</button>
      <button id="reset">Reset</button>
    </div>

    <div class="footer">Animated quarter turns with realistic lighting and reflections.</div>
  </div>

  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.161.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.161.0/examples/jsm/"
      }
    }
  </script>
  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    const app = document.getElementById('app');
    const hudPanel = document.getElementById('hudPanel');
    const hudToggle = document.getElementById('hudToggle');
    const scene = new THREE.Scene();
    const defaultCameraPos = new THREE.Vector3(5.6, 4.2, 6.2);
    const mobileCameraPos = new THREE.Vector3(7.6, 5.4, 8.7);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.12;
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    app.appendChild(renderer.domElement);

    const camera = new THREE.PerspectiveCamera(48, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.copy(defaultCameraPos);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.08;
    controls.minDistance = 4;
    controls.maxDistance = 13;

    const ambient = new THREE.AmbientLight(0xffffff, 0.35);
    scene.add(ambient);

    const key = new THREE.DirectionalLight(0xffffff, 1.1);
    key.position.set(8, 12, 9);
    scene.add(key);

    const fill = new THREE.DirectionalLight(0x8ab5ff, 0.45);
    fill.position.set(-8, 2, -7);
    scene.add(fill);

    const floorGeo = new THREE.CircleGeometry(8, 80);
    const floorMat = new THREE.MeshStandardMaterial({
      color: 0x10141f,
      metalness: 0.35,
      roughness: 0.65,
      transparent: true,
      opacity: 0.8
    });
    const floor = new THREE.Mesh(floorGeo, floorMat);
    floor.rotation.x = -Math.PI / 2;
    floor.position.y = -2.3;
    scene.add(floor);

    const cubeRoot = new THREE.Group();
    scene.add(cubeRoot);

    const C = {
      U: 0xffffff,
      D: 0xffd500,
      F: 0x1fa34a,
      B: 0x0051ba,
      R: 0xc41e3a,
      L: 0xff5800,
      N: 0x111111
    };

    const cubies = [];
    const spacing = 1.04;
    const bodyGeo = new THREE.BoxGeometry(0.98, 0.98, 0.98);

    function stickerMaterials(ix, iy, iz) {
      return [
        new THREE.MeshPhysicalMaterial({ color: ix === 1 ? C.R : C.N, roughness: 0.35, metalness: 0.05, clearcoat: 0.7 }),
        new THREE.MeshPhysicalMaterial({ color: ix === -1 ? C.L : C.N, roughness: 0.35, metalness: 0.05, clearcoat: 0.7 }),
        new THREE.MeshPhysicalMaterial({ color: iy === 1 ? C.U : C.N, roughness: 0.35, metalness: 0.05, clearcoat: 0.7 }),
        new THREE.MeshPhysicalMaterial({ color: iy === -1 ? C.D : C.N, roughness: 0.35, metalness: 0.05, clearcoat: 0.7 }),
        new THREE.MeshPhysicalMaterial({ color: iz === 1 ? C.F : C.N, roughness: 0.35, metalness: 0.05, clearcoat: 0.7 }),
        new THREE.MeshPhysicalMaterial({ color: iz === -1 ? C.B : C.N, roughness: 0.35, metalness: 0.05, clearcoat: 0.7 })
      ];
    }

    function buildCube() {
      for (const c of cubies) cubeRoot.remove(c.mesh);
      cubies.length = 0;

      for (let x = -1; x <= 1; x++) {
        for (let y = -1; y <= 1; y++) {
          for (let z = -1; z <= 1; z++) {
            const mesh = new THREE.Mesh(bodyGeo, stickerMaterials(x, y, z));
            mesh.position.set(x * spacing, y * spacing, z * spacing);
            cubeRoot.add(mesh);
            cubies.push({ mesh, grid: new THREE.Vector3(x, y, z) });
          }
        }
      }
    }

    buildCube();

    const turnDefs = {
      U: { axis: new THREE.Vector3(0, 1, 0), layer: c => c.grid.y === 1 },
      D: { axis: new THREE.Vector3(0, -1, 0), layer: c => c.grid.y === -1 },
      R: { axis: new THREE.Vector3(1, 0, 0), layer: c => c.grid.x === 1 },
      L: { axis: new THREE.Vector3(-1, 0, 0), layer: c => c.grid.x === -1 },
      F: { axis: new THREE.Vector3(0, 0, 1), layer: c => c.grid.z === 1 },
      B: { axis: new THREE.Vector3(0, 0, -1), layer: c => c.grid.z === -1 }
    };

    const queue = [];
    let active = null;

    function snap(n) {
      return Math.round(n);
    }

    function enqueue(move, prime = false, turns = 1) {
      queue.push({ move, prime, turns });
    }

    function startMove({ move, prime, turns }) {
      const def = turnDefs[move];
      if (!def) return;

      const pivot = new THREE.Group();
      cubeRoot.add(pivot);
      const layerCubies = cubies.filter(def.layer);

      for (const c of layerCubies) pivot.attach(c.mesh);

      const sign = prime ? -1 : 1;
      const target = sign * turns * (Math.PI / 2);

      active = {
        move,
        pivot,
        cubies: layerCubies,
        axis: def.axis.clone().normalize(),
        angle: 0,
        target,
        speed: 5.2
      };
    }

    function finalizeMove() {
      const { pivot, cubies: layerCubies } = active;

      for (const c of layerCubies) {
        cubeRoot.attach(c.mesh);

        c.mesh.position.set(
          snap(c.mesh.position.x / spacing) * spacing,
          snap(c.mesh.position.y / spacing) * spacing,
          snap(c.mesh.position.z / spacing) * spacing
        );

        const rot = new THREE.Matrix4().makeRotationFromQuaternion(c.mesh.quaternion);
        const e = rot.elements;
        const idx = [0, 1, 2, 4, 5, 6, 8, 9, 10];
        for (const i of idx) e[i] = snap(e[i]);
        c.mesh.quaternion.setFromRotationMatrix(rot);

        c.grid.set(
          snap(c.mesh.position.x / spacing),
          snap(c.mesh.position.y / spacing),
          snap(c.mesh.position.z / spacing)
        );
      }

      cubeRoot.remove(pivot);
      active = null;
    }

    function updateMove(dt) {
      if (!active && queue.length > 0) startMove(queue.shift());
      if (!active) return;

      const remain = active.target - active.angle;
      const step = Math.sign(remain) * Math.min(Math.abs(remain), active.speed * dt);

      active.pivot.rotateOnAxis(active.axis, step);
      active.angle += step;

      if (Math.abs(active.target - active.angle) < 1e-4) finalizeMove();
    }

    const moveContainer = document.getElementById('moves');
    const moves = ['U', "U'", 'D', "D'", 'L', "L'", 'R', "R'", 'F', "F'", 'B', "B'"];

    for (const label of moves) {
      const b = document.createElement('button');
      b.textContent = label;
      b.addEventListener('click', () => {
        const move = label[0];
        const prime = label.endsWith("'");
        enqueue(move, prime);
      });
      moveContainer.appendChild(b);
    }

    document.getElementById('reset').addEventListener('click', () => {
      queue.length = 0;
      active = null;
      while (cubeRoot.children.length) cubeRoot.remove(cubeRoot.children[0]);
      buildCube();
    });

    document.getElementById('scramble').addEventListener('click', () => {
      const names = ['U', 'D', 'L', 'R', 'F', 'B'];
      for (let i = 0; i < 24; i++) {
        const m = names[Math.floor(Math.random() * names.length)];
        enqueue(m, Math.random() > 0.5);
      }
    });

    const mobileHudQuery = window.matchMedia('(max-width: 768px)');

    function setHudCollapsed(collapsed) {
      hudPanel.classList.toggle('mobile-collapsed', collapsed);
      hudToggle.textContent = collapsed ? 'Show Controls' : 'Hide Controls';
      hudToggle.setAttribute('aria-expanded', String(!collapsed));
    }

    function applyMobileFraming(isMobile, resetCamera = false) {
      cubeRoot.position.y = isMobile ? -1.15 : 0;
      controls.target.set(0, isMobile ? 0.35 : 0, 0);
      controls.minDistance = isMobile ? 6.0 : 4;
      controls.maxDistance = isMobile ? 17 : 13;

      if (resetCamera) {
        camera.position.copy(isMobile ? mobileCameraPos : defaultCameraPos);
      }

      controls.update();
    }

    function syncHudForViewport() {
      if (mobileHudQuery.matches) {
        if (!hudPanel.dataset.mobileInit) {
          setHudCollapsed(true);
          applyMobileFraming(true, true);
          hudPanel.dataset.mobileInit = '1';
        }
      } else {
        setHudCollapsed(false);
        applyMobileFraming(false, true);
        delete hudPanel.dataset.mobileInit;
      }
    }

    hudToggle.addEventListener('click', () => {
      if (!mobileHudQuery.matches) return;
      setHudCollapsed(!hudPanel.classList.contains('mobile-collapsed'));
    });

    mobileHudQuery.addEventListener('change', syncHudForViewport);
    syncHudForViewport();

    window.addEventListener('keydown', (e) => {
      if (e.repeat) return;
      const key = e.key.toUpperCase();
      if (!turnDefs[key]) return;
      enqueue(key, e.shiftKey);
    });

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    });

    const clock = new THREE.Clock();

    function animate() {
      requestAnimationFrame(animate);
      const dt = Math.min(0.033, clock.getDelta());
      updateMove(dt);
      controls.update();
      renderer.render(scene, camera);
    }

    animate();
  </script>
</body>
</html>
